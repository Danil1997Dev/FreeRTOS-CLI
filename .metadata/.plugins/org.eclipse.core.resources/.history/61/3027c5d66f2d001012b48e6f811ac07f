/*
 * app_cli.c
 *
 *  Created on: Mar 23, 2025
 *      Author: user
 */

#ifndef CLI_COMMANDS_H
#define CLI_COMMANDS_H

#include "app_cli.h"

#include "lwip.h"
#include "socket.h"

TaskHandle_t cliTaskHandle[5];
uint8_t buf[MAX_FILE_BUF_LENGTH];
char cOutputBuffer[configCOMMAND_INT_MAX_OUTPUT_SIZE],pcInputString[MAX_INPUT_LENGTH];
uint8_t cRxedChar;

const char * cli_prompt = "\r\ncli> ";
char *remout_ip = "\0";
uint16_t remout_port = 0;
/* CLI escape sequences*/
uint8_t backspace[] = "\b \b";
uint8_t backspace_tt[] = " \b";

int _write(int file, char *data, int len)
{
    UNUSED(file);
    // Transmit data using UART2
    for (int i = 0; i < len; i++)
    {
        // Send the character
    	HAL_UART_Transmit(&huart3, (const uint8_t*)&data[i], 1, 0xffff);
        // Wait for the transmit buffer to be empty
//        while (!(USART3->ISR & USART_ISR_TXE));
    }
    return len;
}
//*****************************************************************************
BaseType_t cmd_clearScreen(char *pcWriteBuffer, size_t xWriteBufferLen,
                                  const char *pcCommandString)
{
    /* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
    (void)pcCommandString;
    (void)xWriteBufferLen;
    memset(pcWriteBuffer, 0x00, xWriteBufferLen);
    cliWrite("\033[2J\033[1;1H");
//    printf("\033[2J\033[1;1H");
    return pdFALSE;
}
//*****************************************************************************
BaseType_t cmd_fs(char *pcWriteBuffer, size_t xWriteBufferLen,
                                 const char *pcCommandString)
{
    const char *pcParameter1;
    BaseType_t xParameter1StringLength;
    notify_struct_t ret_strct;
    notify_struct_t *p_ret_strct = &ret_strct;


    uint8_t *string = malloc(sizeof(uint8_t) * configCOMMAND_INT_MAX_OUTPUT_SIZE);
    /* Obtain the name of the source file, and the length of its name, from
    the command string. The name of the source file is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
						  &xParameter1StringLength
                        );

    if (pcParameter1 == (const char *)"-m")
    {
    	mount_fs(&fs, FS_MOUNT);

    }
    else if (pcParameter1 == (const char *)"-u")
    {
    	mount_fs(&fs, FS_UNMOUNT);

    }
    else
    {

    	strcpy(pcWriteBuffer, (char *)"incorrect parameter");
    }
//    xSemaphoreGive(fsSemHandle);
//    vTaskPrioritySet(vFatFSTaskHandle, osPriorityHigh);
//    taskYIELD();
    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
	xTaskNotify(vFatFSTaskHandle, (uint32_t)p_ret_strct, eSetValueWithOverwrite);
	xTaskNotifyWait(0, 0, (uint32_t)&p_ret_strct, portMAX_DELAY);
    if (p_ret_strct->ret == 0)
    {
    	string = "\r\n---FS comleted!---\r\n";
    }
    else
    {
    	string = "\r\n---FS no comleted!---\r\n";
    }

    strcpy(pcWriteBuffer, (char *)string);

    free(string);

    return pdFALSE;
}
//*****************************************************************************
BaseType_t cmd_connect_ip(char *pcWriteBuffer, size_t xWriteBufferLen,
                                 const char *pcCommandString)
{
    const char *pcParameter1, *pcParameter2;
    BaseType_t xParameter1StringLength, xParameter2StringLength;
    char *addr_len;
    uint32_t ret_con;
    uint8_t *string = malloc(sizeof(uint8_t) * configCOMMAND_INT_MAX_OUTPUT_SIZE);
    uint32_t bytesReading;
    notify_struct_t ret_strct;
    notify_struct_t *p_ret_strct = &ret_strct;

    /* Obtain the name of the source file, and the length of its name, from
    the command string. The name of the source file is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
						  &xParameter1StringLength
                        );

    pcParameter2 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          2,
                          /* Store the parameter string length. */
						  &xParameter2StringLength
                        );

    remout_port = atoi(pcParameter2);
    addr_len = strstr(pcParameter1, " ");
    *addr_len = '\0';
    remout_ip = (char *)pcParameter1;

    strcpy(p_ret_strct->val, "google.pem");
    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
	xTaskNotify(vFatFSTaskHandle, (uint32_t)p_ret_strct, eSetValueWithOverwrite);

    xTaskNotifyWait(0, 0, (uint32_t)&p_ret_strct, portMAX_DELAY);
//    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
//    xTaskNotifyGive(vFatFSTaskHandle);
//    xTaskNotifyWait(0, 0, &ret_con, portMAX_DELAY);
//

    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
    xTaskNotify(vClientTaskHandle, (uint32_t)p_ret_strct, eSetValueWithOverwrite);
    xTaskNotifyWait(0, 0, &p_ret_strct, portMAX_DELAY);
    if (p_ret_strct->ret == 0)
    {
    	string = "\r\n---Connected!---\r\n";
    }
    else
    {
    	string = "\r\n---No connected!---\r\n";
    }

    strcpy(pcWriteBuffer, (char *)string);

    free(string);

    return pdFALSE;
}

BaseType_t cmd_connect_name(char *pcWriteBuffer, size_t xWriteBufferLen,
                                 const char *pcCommandString)
{
    const char *pcParameter1, *pcParameter2;
    BaseType_t xParameter1StringLength, xParameter2StringLength;
    char *addr_len;
    uint32_t ret_con;
    uint8_t *string = malloc(sizeof(uint8_t) * configCOMMAND_INT_MAX_OUTPUT_SIZE);
    uint32_t bytesReading;
    notify_struct_t ret_strct;
    notify_struct_t *p_ret_strct = &ret_strct;

    /* Obtain the name of the source file, and the length of its name, from
    the command string. The name of the source file is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
						  &xParameter1StringLength
                        );

    char *remout_host = malloc(sizeof(uint8_t) * xParameter1StringLength);

    remout_host = (char *)pcParameter1;

    strcpy(p_ret_strct->val, remout_host);
    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
	xTaskNotify(vFatFSTaskHandle, (uint32_t)p_ret_strct, eSetValueWithOverwrite);

    xTaskNotifyWait(0, 0, (uint32_t)&p_ret_strct, portMAX_DELAY);
//    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
//    xTaskNotifyGive(vFatFSTaskHandle);
//    xTaskNotifyWait(0, 0, &ret_con, portMAX_DELAY);
//

    cliTaskHandle[0] = xTaskGetCurrentTaskHandle();
    xTaskNotify(vClientTaskHandle, (uint32_t)p_ret_strct, eSetValueWithOverwrite);
    xTaskNotifyWait(0, 0, &p_ret_strct, portMAX_DELAY);
    if (p_ret_strct->ret == 0)
    {
    	string = "\r\n---Connected!---\r\n";
    }
    else
    {
    	string = "\r\n---No connected!---\r\n";
    }

    strcpy(pcWriteBuffer, (char *)string);

    free(string);

    return pdFALSE;
}

const CLI_Command_Definition_t xCommandList[] = {
    {
        .pcCommand = "cls", /* The command string to type. */
        .pcHelpString = "cls:\r\n Clears screen\r\n\r\n",
        .pxCommandInterpreter = cmd_clearScreen, /* The function to run. */
        .cExpectedNumberOfParameters = 0 /* No parameters are expected. */
    },
    {
        .pcCommand = "fs", /* The command string to type. */
        .pcHelpString = "fs:\r\n"
        		"have one parameter with value:\r\n"
        		" mount (-m) or unmount (-u) file system\r\n\r\n",
        .pxCommandInterpreter = cmd_fs, /* The function to run. */
        .cExpectedNumberOfParameters = 1 /* No parameters are expected. */
    },
    {
        .pcCommand = "connect_ip", /* The command string to type. */
        .pcHelpString = "connect_ip:\r\n"
        		" have two parameters\r\n -remout ip address\r\n"
        		" -remout port\r\n\r\n",
        .pxCommandInterpreter = cmd_connect_ip, /* The function to run. */
        .cExpectedNumberOfParameters = 2 /* 2 parameters are expected. */
    },
    {
        .pcCommand = "connect_name", /* The command string to type. */
        .pcHelpString = "connect_ip:\r\n"
        		" have one parameter\r\n -remout host name\r\n",
        .pxCommandInterpreter = cmd_connect_name, /* The function to run. */
        .cExpectedNumberOfParameters = 1 /* 1 parameters are expected. */
    },
    {
        .pcCommand = NULL /* simply used as delimeter for end of array*/
    }
};

void vRegisterCLICommands(void){
    //itterate thourgh the list of commands and register them
    for (int i = 0; xCommandList[i].pcCommand != NULL; i++)
    {
        FreeRTOS_CLIRegisterCommand(&xCommandList[i]);
    }
}
/*************************************************************************************************/
void cliWrite(const char *str)
{
   printf("%s", str);
   // flush stdout
   fflush(stdout);
}
/*************************************************************************************************/
void handleNewline(const char *const pcInputString, char *cOutputBuffer, uint8_t *cInputIndex)
{
    cliWrite("\r\n");

    BaseType_t xMoreDataToFollow;
    do
    {
        xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString, cOutputBuffer, configCOMMAND_INT_MAX_OUTPUT_SIZE);
        cliWrite(cOutputBuffer);
    } while (xMoreDataToFollow != pdFALSE);

    cliWrite(cli_prompt);
    *cInputIndex = 0;
    memset((void*)pcInputString, 0x00, MAX_INPUT_LENGTH);
}
/*************************************************************************************************/
void handleBackspace(uint8_t *cInputIndex, char *pcInputString)
{
    if (*cInputIndex > 0)
    {
        (*cInputIndex)--;
        pcInputString[*cInputIndex] = '\0';

#if USING_VS_CODE_TERMINAL
        cliWrite((char *)backspace);
#elif USING_OTHER_TERMINAL
        cliWrite((char *)backspace_tt);
#endif
    }
    else
    {
#if USING_OTHER_TERMINAL
        uint8_t right[] = "\x1b\x5b\x43";
        cliWrite((char *)right);
#endif
    }
}
/*************************************************************************************************/
void handleCharacterInput(uint8_t *cInputIndex, char *pcInputString)
{
    if (cRxedChar == '\r')
    {
        return;
    }
    else if (cRxedChar == (uint8_t)0x08 || cRxedChar == (uint8_t)0x7F)
    {
        handleBackspace(cInputIndex, pcInputString);
    }
    else
    {
        if (*cInputIndex < MAX_INPUT_LENGTH)
        {
            pcInputString[*cInputIndex] = cRxedChar;
            (*cInputIndex)++;
        }
    }
}
#endif /* CLI_COMMANDS_H */
