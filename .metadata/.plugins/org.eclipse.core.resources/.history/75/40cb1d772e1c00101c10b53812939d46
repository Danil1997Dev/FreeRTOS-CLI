/*
 * app_cli.c
 *
 *  Created on: Mar 23, 2025
 *      Author: user
 */

#ifndef CLI_COMMANDS_H
#define CLI_COMMANDS_H

#include "app_cli.h"

#include "lwip.h"
#include "socket.h"

char cOutputBuffer[configCOMMAND_INT_MAX_OUTPUT_SIZE],pcInputString[MAX_INPUT_LENGTH];
uint8_t cRxedChar;
const char * cli_prompt = "\r\ncli> ";
char *remout_ip = "\0";
uint16_t remout_port = 0;
msg_t msg_struct;
/* CLI escape sequences*/
uint8_t backspace[] = "\b \b";
uint8_t backspace_tt[] = " \b";

int _write(int file, char *data, int len)
{
    UNUSED(file);
    // Transmit data using UART2
    for (int i = 0; i < len; i++)
    {
        // Send the character
    	HAL_UART_Transmit(&huart3, (const uint8_t*)&data[i], 1, 0xffff);
        // Wait for the transmit buffer to be empty
//        while (!(USART3->ISR & USART_ISR_TXE));
    }
    return len;
}
//*****************************************************************************
BaseType_t cmd_clearScreen(char *pcWriteBuffer, size_t xWriteBufferLen,
                                  const char *pcCommandString)
{
    /* Remove compile time warnings about unused parameters, and check the
	write buffer is not NULL.  NOTE - for simplicity, this example assumes the
	write buffer length is adequate, so does not check for buffer overflows. */
    (void)pcCommandString;
    (void)xWriteBufferLen;
    memset(pcWriteBuffer, 0x00, xWriteBufferLen);
    printf("\033[2J\033[1;1H");
    return pdFALSE;
}
//*****************************************************************************
BaseType_t cmd_fs(char *pcWriteBuffer, size_t xWriteBufferLen,
                                 const char *pcCommandString)
{
    const char *pcParameter1;
    BaseType_t xParameter1StringLength;

    /* Obtain the name of the source file, and the length of its name, from
    the command string. The name of the source file is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
						  &xParameter1StringLength
                        );

    if (pcParameter1 == (const char *)"-m")
    {
    	mount_fs(&fs, FS_MOUNT);

    }
    else if (pcParameter1 == (const char *)"-u")
    {
    	mount_fs(&fs, FS_UNMOUNT);

    }
    else
    {

    	strcpy(pcWriteBuffer, (char *)"incorrect parameter");
    }
    xSemaphoreGive(fsSemHandle);
    uint8_t string[] = "\r\nfs comlited\r\n";
    strcpy(pcWriteBuffer, (char *)string);

    return pdFALSE;
}
//*****************************************************************************
BaseType_t cmd_connect(char *pcWriteBuffer, size_t xWriteBufferLen,
                                 const char *pcCommandString)
{
    const char *pcParameter1, *pcParameter2;
    BaseType_t xParameter1StringLength, xParameter2StringLength;
    char *addr_len;

    /* Obtain the name of the source file, and the length of its name, from
    the command string. The name of the source file is the first parameter. */
    pcParameter1 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          1,
                          /* Store the parameter string length. */
						  &xParameter1StringLength
                        );

    pcParameter2 = FreeRTOS_CLIGetParameter
                        (
                          /* The command string itself. */
                          pcCommandString,
                          /* Return the first parameter. */
                          2,
                          /* Store the parameter string length. */
						  &xParameter2StringLength
                        );

    remout_port = atoi(pcParameter2);
    addr_len = strstr(pcParameter1, " ");
    *addr_len = '\0';
    remout_ip = (char *)pcParameter1;
    uint8_t string[] = "\r\nConnected!\r\n";
    cliWrite((char *)"Connection...\r\n", strlen("Connection...\r\n"));
    xSemaphoreGive(connectSemHandle);
    strcpy(pcWriteBuffer, (char *)string);

    return pdFALSE;
}

const CLI_Command_Definition_t xCommandList[] = {
    {
        .pcCommand = "cls", /* The command string to type. */
        .pcHelpString = "cls:\r\n Clears screen\r\n\r\n",
        .pxCommandInterpreter = cmd_clearScreen, /* The function to run. */
        .cExpectedNumberOfParameters = 0 /* No parameters are expected. */
    },
    {
        .pcCommand = "fs", /* The command string to type. */
        .pcHelpString = "fs:\r\n"
        		"have one parameter with value:\r\n"
        		" mount (-m) or unmount (-u) file system\r\n\r\n",
        .pxCommandInterpreter = cmd_fs, /* The function to run. */
        .cExpectedNumberOfParameters = 1 /* No parameters are expected. */
    },
    {
        .pcCommand = "connect", /* The command string to type. */
        .pcHelpString = "connect:\r\n"
        		" have two parameters\r\n -remout ip address\r\n"
        		" -remout port\r\n\r\n",
        .pxCommandInterpreter = cmd_connect, /* The function to run. */
        .cExpectedNumberOfParameters = 2 /* 2 parameters are expected. */
    },
    {
        .pcCommand = NULL /* simply used as delimeter for end of array*/
    }
};

void vRegisterCLICommands(void){
    //itterate thourgh the list of commands and register them
    for (int i = 0; xCommandList[i].pcCommand != NULL; i++)
    {
        FreeRTOS_CLIRegisterCommand(&xCommandList[i]);
    }
}
/*************************************************************************************************/
void cliWrite(const char *str, uint32_t len)
{
//   printf("%s", str);
//   // flush stdout
//   fflush(stdout);
	msg_struct.print_msg = str;
	msg_struct.len = len;
	vTaskPrioritySet(vPrintTaskHandle, osPriorityHigh);
	xSemaphoreGive(printSemHandle);
}
/*************************************************************************************************/
void handleNewline(const char *const pcInputString, char *cOutputBuffer, uint32_t len_out, uint8_t *cInputIndex)
{
    cliWrite("\r\n",strlen("\r\n"));

    BaseType_t xMoreDataToFollow;
    do
    {
        xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString, cOutputBuffer, configCOMMAND_INT_MAX_OUTPUT_SIZE);
        cliWrite(cOutputBuffer, len_out);
    } while (xMoreDataToFollow != pdFALSE);

    cliWrite(cli_prompt, strlen(cli_prompt));
    *cInputIndex = 0;
    memset((void*)pcInputString, 0x00, MAX_INPUT_LENGTH);
}
/*************************************************************************************************/
void handleBackspace(uint8_t *cInputIndex, char *pcInputString)
{
    if (*cInputIndex > 0)
    {
        (*cInputIndex)--;
        pcInputString[*cInputIndex] = '\0';

#if USING_VS_CODE_TERMINAL
        cliWrite((char *)backspace);
#elif USING_OTHER_TERMINAL
        cliWrite((char *)backspace_tt, (uint32_t)strlen(backspace_tt));
#endif
    }
    else
    {
#if USING_OTHER_TERMINAL
        uint8_t right[] = "\x1b\x5b\x43";
        cliWrite((char *)right, (uint32_t)strlen(right));
#endif
    }
}
/*************************************************************************************************/
void handleCharacterInput(uint8_t *cInputIndex, char *pcInputString)
{
    if (cRxedChar == '\r')
    {
        return;
    }
    else if (cRxedChar == (uint8_t)0x08 || cRxedChar == (uint8_t)0x7F)
    {
        handleBackspace(cInputIndex, pcInputString);
    }
    else
    {
        if (*cInputIndex < MAX_INPUT_LENGTH)
        {
            pcInputString[*cInputIndex] = cRxedChar;
            (*cInputIndex)++;
        }
    }
}
#endif /* CLI_COMMANDS_H */
